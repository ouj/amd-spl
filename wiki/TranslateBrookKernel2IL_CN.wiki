#summary 介绍Brook+的kernel到IL的转化方法和优化技巧

= 引言 =

进行GPGPU编程，很多人（包括我在内）会选择从Brook+入手。Brook+的kernel编写是基于C语言的，易于编写和理解，而且Brook+的运行时处理了很多繁琐的细节，使到GPGPU编程变得非常的简单。但是随着设计和应用的深入，Brook+就不再是理想的GPGPU的编程语言了。主要原因有两个：
# Brook+的运行时效率不高，调用kernel有一定的额外开销，而且无法支持多GPU
# Brook+的kernel不支持高级的GPU命令，比如本地共享内存和原子操作等
基于以上的两个原因，CAL就更加适合深入的进行GPGPU开发。因为它暴露更多的显卡特性，允许程序员对GPGPU的资源和流程进行精细的控制。

在进行Brook+编程的时候，所有的Brook+的kernel会由brcc转化成IL。但是，要使用CAL进行GPGPU开发，就必须进行IL的编写。IL是指AMD Intermediate Language。是一种汇编形式的语言。有些人一听到是汇编语言就会感到非常难以理解和编写。实际上并不是这样子。一旦有了Brook+的kernel我们就可以很容易的把它转化为IL并进行优化。本文将会通过一个例子介绍如何把Brook+的kernel转化为IL并且对其进行优化。

= IL开发环境 =

IL代码和大多数的编程语言的代码一样，是纯文本。因此，可以使用任何的文本编辑器进行编写。这里推荐使用AMD提供的一个工具，Stream KernelAnalyzer（以下简称SKA）。这个工具可以在AMD的官方网站上下载得到。GPGPU开发者可以在SKA上进行Brook+内核编写，IL程序编写，甚至是直接的显卡汇编的编写。SKA会对输入的代码进行语法检测和编译，给出对应的在每一个型号的GPU上的汇编码和一些相关的性能分析以供参考。

SKA提供的性能分析可能并不是实际的执行结果，但是却可以为GPGPU开发者提供很好的参考。开发者可以通过设置SKA的显示选项来查看更多的性能参数，在这篇文章里面我们主要关注两个性能参数，Ave Cycle和Throughput。越低的Cycle和越高的Throughput表明GPGPU程序越高效。

= BITONIC的BROOK+实现 =
在这篇文章里面，我们不会详细介绍Bitonic排序的原理。我们使用Brook+开发包自带的Bitonic排序实现来举例介绍IL的开发。关于Brook+资源分配与调用请参看相关的文档。这里主要关注Brook+的kernel，因为这是Brook+中会被brcc编译器转化为IL的代码。的Brook+中自带的Bitonic排序的kernel代码如下：
{{{
kernel void 
bitonic(float input[], out float output<>, float stageWidth, float offset, float twoOffset)
{
    float idx2;
    float sign, dir;
    float min, max;
    float idx1 = (float)instance().x;

    // Either compared with element above or below
    sign = (fmod(idx1, twoOffset) < offset) ? 1.0f : -1.0f;

    // "Arrow" direction in the bitonic search algorithm (see above reference)
    dir = (fmod(floor(idx1 / stageWidth), 2.0f) == 0.0f) ? 1.0f: -1.0f;

    // comparing elements idx1 and idx2
    idx2 = idx1 + sign * offset;

    min = (input[idx1] < input[idx2]) ? input[idx1] : input[idx2];
    max = (input[idx1] > input[idx2]) ? input[idx1] : input[idx2];

    output = (sign == dir) ? min : max;
}
}}}
在Brook+中，这一段C语言的kernel代码会被转化成两个版本的IL，一个是没有进行地址转换的，另一个是进行了地址转换※（Address Translation，以下简称AT）。这两份IL可以在KSA中通过选择不同的function看到。把以上的代码复制到SKA的代码编写区，就可以马上在输出区看到对应的IL代码。并且可以在相关性能分析。我们可以看到在HD4870的显卡上的Ave Cycle为1.90，throughput为6316M Thread/sec，并不是十分的高效。如果使用了AT，效率就更低了，Ave Cycle为6.62，Throughput仅为2264M Thread/sec。而且，SKA生成的IL有很多冗余的命令，虽然这些冗余在转化为汇编的时候都会被IL编译器优化掉，但是这些冗余却对程序的可读性带来很大的影响。基于效率和可读性的原因，我们需要自己来编写IL。本文除了介绍怎么从上面的Brook+ kernel转化为IL，还会介绍一些基本优化技巧，把Throughput提升到极限。

= 把BROOK+程序转化为IL =
一个标准的IL程序由两个个部分组成，分别为声明部分和程序体部分。其中声明部分用于声明IL中会用到的所有资源。包括输入资源，输出寄存器等。

== IL的类型与版本 ==
所有IL中的第一条语句用于声明IL的版本和类型：
{{{
il_ps_2_0
}}}
个IL使用Pixel Shader的方式，版本为2.0版。另外一个可能的IL类型是cs。cs只能用在支持computating shader的显卡上，本文并不会详细介绍。
== 输入的声明 ==
细心观察Bitonic排序的kernel，我们可以发现这个kernel有一个输入流，一个输出流和三个常量。这些需要转化为IL中的声明。对输出流的声明，因为只有一个输出流，只需要定义o0一个输出寄存器。IL程序的最终输出结果要写到这个寄存器中。
{{{
dcl_output_generic o0
}}}
对输入流的声明是一个资源与一个输入坐标，通过输入坐标对资源进行采样可以获得输入流的值
{{{
dcl_resource_id(0)_type(2d,unnorm)_fmtx(float)_fmty(float)_fmtz(float)_fmtw(float)
dcl_input_position_interp(linear_noperspective) v0.xy__
}}}
所有的常量都被组织在一个常量缓存中
{{{
dcl_cb cb0[3]
}}}
另外，我们还需要定义一些会被用到的立即数
{{{
dcl_literal l1, 0xFFFFFFFF, 0x00000001, 0x00000000, 0xFFFFFFFF
}}}

有了这些声明，我们就可以进入IL程序体的编写了。

== 分割细化BROOK+程序 ==
因为IL是一种中间语言，类似于汇编，因此其语法比较简单，每一条IL命令只能完成一个运算操作。因此，为了便于理解，我们需要把Brook+的kernel进行分解，转化成一系列的操作序列。因为IL中的不存在变量的概念，只有寄存器的概念，而寄存器是变量名的，所以我们把变量名也用共用寄存器代替了。
{{{
[in i0[], out o0<>, c0, c1, c2] //declaration
{
r1 = (float)instance().x;   // idx1 = r1 = (float)instance().x;

r3 = r1 % c2                // r3 = fmod(idx1, twoOffset)
r3 = r3 < c1                // r3 = fmod(idx1, twoOffset) < offset
r3 = r3 ? 1.0f : -1.0f      // sign = r3 = (fmod(idx1, twoOffset) < offset) ? 1.0f : -1.0f;

r4 = r1 / c0                // r4 = idx1 / stageWidth
r4 = floor(r5)              // r4 = floor(idx1 / stageWidth)
r4 = r4 % 2.0f              // r4 = floor(idx1 / stageWidth) % 2.0f
r4 = r4 == 0.0f             // r4 = fmod(floor(idx1 / stageWidth), 2.0f) == 0.0f
r4 = r4 ? 1.0f : -1.0f      // dir = r4 = (fmod(floor(idx1 / stageWidth), 2.0f) == 0.0f) ? 1.0f: -1.0f
r2 = r3 * c1                // r2 = sign * offset;
r2 = r2 + r1                // idx2 = r2 = idx1 + sign * offset;

r5 = i0[r1]                 // r5 = input[idx1]
r6 = i0[r2]                 // r6 = input[idx2]

r7 = r5 < r6                // r7 = input[idx1] < input[idx2]
r7 = r7 ? r5 : r6           // min = r7 = (input[idx1] < input[idx2]) ? input[idx1] : input[idx2]
r8 = r5 > r6                // r8 = input[idx1] > input[idx2]
r8 = r8 ? r5 : r6           // max = r8 = (input[idx1] > input[idx2]) ? input[idx1] : input[idx2]

r9 = r3 == r4               // r9 = sign == dir
o0 = r9 ? r7 : r8           // output = (sign == dir) ? min : max;
}
}}}

= 待续... =




----
※目前因为显卡分配的一维显存空间的长度存在限制，如HD4870为8192个元素。如果要提供大型一维数组，或者多维数组的支持，必须使用地址转换技术使用二维数组来模拟。但是，进行地址转换，就需要在内核中增加数据索引计算的操作，会减低计算的效率。