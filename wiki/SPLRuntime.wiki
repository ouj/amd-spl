#summary the SPL runtime

= Introduction =

The CAL runtime provide GPGPU service to the entire SPL. It is a wrapper of the underlying CAL function call. 

= UML class Diagram =
[http://i671.photobucket.com/albums/vv74/ojavax/AMD-SPL/Runtimestructure.jpg]

= Runtime initialization =
CAL runtime uses the singleton design parttern. `Runtime::getInstance()` is used to get the pointer of Runtime instance. In `AmdSpl::Initailized()`, `Runtime::getInstance()` is called, then a Runtime instance is created and its `Runtime::create()` method is called. In the `Runtime::create()` method, the following things are done:

== CAL initialization ==
the `Runtime::create()` method will call `calInit()` to initialize the CAL. If `calInit()` returns `CAL_RESULT_OK`, that means CAL is initialized successfully, and Runtime is responsible for its shutdown when destroyed. If `calInit()` returns `CAL_RESULT_ALREADY`, that means CAL is already initialized somewhere else in the same program. Then the SPL will not call calShutdown when destroyed.

== Create manager classes ==
A set of manager classes, including [SPLDeviceManagement DeviceManager], [SPLBufferManagement BufferManager], [SPLProgramManagement ProgramManager] and [SPLConstBufferManagement ConstBufferPool] is created and initialized in `Runtime::create()`

= Runtime destruction =
The `Runtime` class defines a static method named `void Runtime::destroy()` to do cleanup task. This method will be called under two circumstances. 
  #The user calls `AmdSpl::CleanupSPL()`
  #The program exits. (`Runtime::destroy()` is registered as a cleanup function using `atexit`)
In `void Runtime::destroy()`, all the resource created by SPL will be released, and the singleton object of Runtime will be deleted.

= Get managers =
The Runtime class provides a set of get method, so that developer can use them to get the management class instance in other modules of the library.